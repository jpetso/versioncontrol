<?php
// $Id$
/**
 * @file
 * Commit Log - Display a history of commits, branches and tags,
 * optionally filtered by a set of constraint arguments.
 *
 * Copyright 2006, 2007 Derek Wright ("dww" , http://drupal.org/user/46549)
 * Copyright 2007, 2008 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

/**
 * Implementation of hook_menu().
 */
function commitlog_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $access = user_access('access commit messages');
    $items[] = array(
      'path' => 'commitlog',
      'title' => t('Commit Log'),
      'callback' => 'commitlog_operations_page',
      'access' => $access,
      'type' => MENU_SUGGESTED_ITEM,
    );
    $items[] = array(
      'path' => 'commitlog/feed',
      'title' => t('Commit Log'),
      'callback' => 'commitlog_operations_rss',
      'access' => $access,
      'type' => MENU_CALLBACK,
    );

    // Search pages:
/*
    // until this works, no sense displaying this page
    // see http://drupal.org/node/59659
    $items[] = array(
      'path' => 'search/commitlog',
      'title' => t('Commit messages'),
      'callback' => 'commitlog_operations_page_search',
      'access' => $access,
      'type' => MENU_LOCAL_TASK,
      'weight' => 2,
    );
*/
  }
  else {
    if (arg(0) == 'user' && is_numeric(arg(1))) {
      $uid = arg(1);
      $accounts = versioncontrol_get_accounts(array('uids' => array($uid)));
      if (!empty($accounts)) {
        // If the user has a CVS account, add a 'track commit messages' tab to the tracker page.
        $items[] = array(
          'path' => 'user/'. $uid .'/track/code',
          'title' => t('Track code'),
          'callback' => 'commitlog_account_tracker',
          'callback arguments' => array($uid),
          'access' => user_access('access commit messages'),
          'type' => MENU_LOCAL_TASK,
          'weight' => 2,
        );
      }
    }
  }
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function commitlog_perm() {
  return array('access commit messages');
}


/**
 * Implementation of hook_form_alter():
 * Add a fieldset for to the general settings form so that the user can
 * enable/disable admin notification mails and configure the pager limit.
 */
function commitlog_form_alter($form_id, &$form) {
  if ($form['#id'] == 'versioncontrol-settings-form') {
    $form['#validate']['commitlog_settings_validate'] = array();
    $form['#submit']['commitlog_settings_submit'] = array();

    $form['commitlog'] = array(
      '#type' => 'fieldset',
      '#title' => t('Commit Log'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 3,
    );
    $form['commitlog']['commitlog_send_notification_mails'] = array(
      '#type' => 'checkbox',
      '#title' => 'Send commit notification mails to the VCS administrator',
      '#description' => 'If this is enabled, each commit that is recorded on this site causes a notification mail to be sent to the VCS administrator\'s e-mail address. This mail includes all relevant commit data like the commit message and the files and directories that were changed. Note that disabling the Commit Log module also disables notification mails.',
      '#default_value' => variable_get('commitlog_send_notification_mails', 0),
    );
    $form['commitlog']['commitlog_pager'] = array(
      '#type' => 'textfield',
      '#title' => t('Number of commits per page'),
      '#description' => t('Controls how many commits can be shown on a single page of the !commitlog. Paging is used when there are more commits to show than specified by this value.', array('!commitlog' => l(t('Commit Log'), 'commitlog'))),
      '#default_value' => variable_get('commitlog_pager', 10),
    );
  }
}

/**
 * Validation handler for the settings form:
 * Make sure that the pager limit is a positive number.
 */
function commitlog_settings_validate($form_id, $form_values) {
  if (!is_numeric($form_values['commitlog_pager']) || $form_values['commitlog_pager'] <= 0) {
    form_set_error('commitlog_pager', t('The number of commits per page needs to be a positive number.'));
  }
}

/**
 * Submit handler for the settings form.
 */
function commitlog_settings_submit($form_id, $form_values) {
  variable_set('commitlog_pager', $form_values['commitlog_pager']);
  variable_set('commitlog_send_notification_mails', $form_values['commitlog_send_notification_mails']);
}


/**
 * Implementation of hook_versioncontrol_operation():
 * If enabled, send out a notification mail to the VCS admin.
 */
function commitlog_versioncontrol_operation($op, $operation, $operation_items) {
  if ($op == 'insert') {
    if (variable_get('commitlog_send_notification_mails', 0)) {
      $mailto = variable_get('versioncontrol_email_address', 'versioncontrol@example.com');
      commitlog_send_notification_mail($mailto, $operation, $operation_items);
    }
  }
}

/**
 * Send out a notification mail to the given mail address.
 */
function commitlog_send_notification_mail($mailto, $operation, $operation_items) {
  $admin_mail = variable_get('versioncontrol_email_address', 'versioncontrol@example.com');
  $username = commitlog_account_username(
    $operation['uid'], $operation['username'], $operation['repository'], TRUE, 'plaintext'
  );

  $from = "$username <$admin_mail>";
  $subject = theme('commitlog_operation_email_subject',
    $operation, $operation_items, $username
  );
  $message = commitlog_operation($operation, $operation_items, $username, 'plaintext');

  drupal_mail(
    'commitlog_notification_email', $mailto,
    $subject, $message, $from, array('X-Mailer' => 'Drupal')
  );
}

function theme_commitlog_operation_email_subject($operation, $operation_items, $username) {
  // TODO: see if we can unify the two original versions.
  // Previous version for commits.
  $location = theme('commitlog_operation_location', $operation, NULL, 'plaintext');

  // TODO (other than unify): port to the new API
  $params = array(
    '!type' => ($type == 'branch') ? t('Branch') : t('Tag'),
    '!name' => ($type == 'branch') ? $operation['branch_name'] : $operation['tag_name'],
    '!directory' => $operation['directory'],
  );

  // If the branch or tag has been assigned for the whole repository,
  // it doesn't make sense to mention the directory.
  if (empty($items)) {
    return t('!type !name', $params);
  }
  return t('!type !name in !directory', $params);
}


/**
 * Page callback for the 'commitlog' menu path.
 */
function commitlog_operations_page() {
  if ($error_message = _commitlog_check_request()) {
    return $error_message;
  }

  list($constraints, $attributes) = _commitlog_get_constraints();
  $operations = commitlog_get_paged_operations($constraints);

  drupal_add_css(drupal_get_path('module', 'commitlog') .'/commitlog.css');
  return theme('commitlog_operations_page', $operations, $attributes);
}

/**
 * Page callback for the 'track code' tab on the user page.
 */
function commitlog_account_tracker($uid) {
  $user = user_load(array('uid' => $uid));
  if (!$user) {
    drupal_not_found();
    exit();
  }
  $_REQUEST['uids'] = (string) $uid;
  drupal_set_title($user->name);

  list($constraints, $attributes) = _commitlog_get_constraints();
  $operations = commitlog_get_paged_operations($constraints);
  unset($_REQUEST['uids']);

  drupal_add_css(drupal_get_path('module', 'commitlog') .'/commitlog.css');
  return theme('commitlog_operations_page', $operations, $attributes);
}

/**
 * Page callback for the 'commitlog/feed' menu path.
 */
function commitlog_operations_rss() {
  if ($error_message = _commitlog_check_request()) {
    exit();
  }

  list($constraints, $attributes) = _commitlog_get_constraints();
  $limit = variable_get('feed_default_items', 10);
  $operations = commitlog_get_paged_operations($constraints, $limit);

  drupal_set_header('Content-Type: application/rss+xml; charset=utf-8');
  print theme('commitlog_rss', $operations);
  exit();
}


/**
 * Retrieve the commit constraints for the page display by dissecting
 * the $_REQUEST variable.
 *
 * @return
 *   An array($constraints, $attributes) where $constraints is an array of
 *   commit constraints supposed to be passed to versioncontrol_get_operations(),
 *   and $attributes is an associative array of the processed arguments
 *   from $_REQUEST.
 */
function _commitlog_get_constraints() {
  $constraints = array();
  $attributes = array();

  $constraint_request_map = array(
    'vc_op_ids' => array('single' => 'id', 'multiple' => 'ids'),
    'usernames' => array('single' => 'username', 'multiple' => 'usernames'),
    'uids'      => array('single' => 'uid', 'multiple' => 'uids'),
    'vcs'       => array('multiple' => 'vcs'), // 'vcses' just looks too horrible
    'repo_ids'  => array('single' => 'repo', 'multiple' => 'repos'),
    'branches'  => array('single' => 'branch', 'multiple' => 'branches'),
    'tags'      => array('single' => 'tag', 'multiple' => 'tags'),
    'labels'    => array('single' => 'label', 'multiple' => 'labels'),
    'paths'     => array('single' => 'path', 'multiple' => 'paths'),
    // TODO: 'types' constraint
  );

  // Transform query string into query string. We use $_REQUEST because we
  // need to support both GET and POST requests.
  foreach ($constraint_request_map as $constraint => $request) {
    if (isset($request['multiple']) && isset($_REQUEST[$request['multiple']])) {
      $constraints[$constraint] = explode(',', $_REQUEST[$request['multiple']]);
      $attributes[$request['multiple']] = $_REQUEST[$request['multiple']];
    }
    if (isset($request['single']) && isset($_REQUEST[$request['single']])) {
      if (!isset($constraints[$constraint])) {
        $constraints[$constraint] = array();
      }
      $constraints[$constraint][] = $_REQUEST[$request['single']];
      $attributes[$request['single']] = $_REQUEST[$request['single']];
    }
  }

  if (module_exists('versioncontrol_project')) {
    $project_constraints = array();
    if (isset($_REQUEST['nids'])) {
      $project_constraints['nids'] = explode(',', $_REQUEST['nids']);
      $attributes['nids'] = $_REQUEST['nids'];
    }
    if (isset($_REQUEST['maintainers'])) {
      $project_constraints['maintainer_uids'] = explode(',', $_REQUEST['maintainers']);
      $attributes['maintainers'] = $_REQUEST['maintainers'];
    }
    if (!empty($project_constraints)) {
      $constraints = versioncontrol_project_get_commit_constraints(
        $constraints, $project_constraints
      );
    }
  }

  return array($constraints, $attributes);
}

/**
 * Return an array of operations retrieved by versioncontrol_get_operations().
 * Paging is also used by emulating pager_query().
 */
function commitlog_get_paged_operations($constraints, $limit = NULL, $element = 0) {
  global $pager_page_array, $pager_total, $pager_total_items;
  $page = isset($_GET['page']) ? $_GET['page'] : '';
  $pager_page_array = explode(',', $page);
  $page = empty($pager_page_array[$element]) ? 0 : $pager_page_array[$element];

  if (!isset($limit)) {
    $limit = variable_get('commitlog_pager', 10);
  }
  $operations = versioncontrol_get_commits($constraints, $result_count, $page, $limit);

  // Emulate pager_query() in order to get a proper theme('pager').
  $pager_total_items[$element] = $result_count;
  $pager_total[$element] = ceil($pager_total_items[$element] / $limit);
  $pager_page_array[$element] = max(0, min((int)$pager_page_array[$element], ((int)$pager_total[$element]) - 1));

  return $operations;
}

/**
 * Check the $_REQUEST variable if it contains elements that can't be processed
 * in the current Drupal configuration.
 *
 * @return
 *   A string containing the appropriate error message, or NULL if everything
 *   can proceed as planned.
 */
function _commitlog_check_request() {
  if (isset($_REQUEST['nids']) || isset($_REQUEST['maintainers'])) {
    if (!module_exists('versioncontrol_project')) {
      return '<p>'. t('The given commit constraints can\'t be applied as the Version Control / Project Node Integration module is not enabled. In order to use the "nids" or "maintainer_uids" constraints, please enable this module.') .'</p>';
    }
  }
  return NULL;
}


/**
 * Return a formatted date string if the given timestamp is on a different day
 * than the one that was passed previous call to this function, or NULL if the
 * previous call's timestamp argument is on the same day as this one.
 */
function _commitlog_date($timestamp) {
  static $last;
  $date = format_date($timestamp, 'custom', 'F j, Y');
  if ($date != $last) {
    $last = $date;
    return $date;
  }
  return NULL;
}

/**
 * Return formatted output for displaying the given operations on an HTML page.
 */
function theme_commitlog_operations_page($operations, $attributes) {
  if (empty($operations)) {
    return '<div id="commitlog"><p>'. t('No log messages found.') .'</p></div>';
  }

  $output = '<div id="commitlog">';
  $initial = TRUE;

  foreach ($operations as $operation) {
    $operation_items = versioncontrol_get_operation_items($operation);

    $date = _commitlog_date($operation['date']);
    if (isset($date)) { // begin a new list for each day
      if (!$initial) {
        $output .= '</ul>';
      }
      $initial = FALSE;
      $output .= "<h3>$date</h3>";
      $output .= '<ul>';
    }
    $output .= '<li>'. commitlog_operation($operation, $operation_items, NULL, 'html') .'</li>';
  }
  $output .= '</ul>';

  if ($pager = theme('pager', NULL, variable_get('commitlog_pager', 10), 0, $attributes)) {
    $output .= $pager;
  }
  $output .= '</div>';

  $query_items = array();
  foreach ($attributes as $key => $value) {
    $query_items[] = $key .'='. $value;
  }
  $query = empty($query_items) ? NULL : implode('&', $query_items);
  $output .= theme('feed_icon', url('commitlog/feed', $query));

  return $output;
}

function theme_commitlog_rss($commits) {
  global $base_url, $locale;
  $items = '';
  $namespaces = array('xmlns:dc="http://purl.org/dc/elements/1.1/"');

  foreach ($operations as $operation) {
    $operation_items = versioncontrol_get_operation_items($operation);

    $location = theme('commitlog_operation_location', $operation);
    $html_username = commitlog_account_username(
      $operation['uid'], $operation['username'], $operation['repository']
    );
    $plain_username = commitlog_account_username(
      $operation['uid'], $operation['username'], $operation['repository'], TRUE, 'plaintext'
    );

    $title = t('!location by @username', array('!location' => $location, '@username' => $html_username));
    $link = url('commitlog', 'ids='. $commit['vc_op_id'], NULL, TRUE);
    $extra = array(
      array('key' => 'pubDate', 'value' => gmdate('r', $operation['date'])),
      array('key' => 'dc:creator', 'value' => $plain_username),
      array('key' => 'guid',
        'value' => 'Version control operation '. $operation['vc_op_id'] .' at '. $base_url,
        'attributes' => array('isPermaLink' => 'false'),
      ),
    );
    $text = commitlog_operation($operation, $operation_items, $html_username, 'html');
    $items .= format_rss_item($title, $link, $text, $extra);
  }

  $site_name = variable_get('site_name', 'Drupal');

  $channel = array(
    'version'     => '2.0',
    'title'       => t('@site commits', array('@site' => $site_name)),
    'link'        => url('commitlog', NULL, NULL, TRUE),
    'description' => t('Commit messages for @site', array('@site' => $site_name)),
    'language'    => $locale,
  );
  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<rss version=\"". $channel['version'] ."\" xml:base=\"". $base_url ."\" ". implode(' ', $namespaces) .">\n";
  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);
  $output .= "</rss>\n";

  return $output;
}

function commitlog_operation($operation, $operation_items, $username = NULL, $format = 'html') {
  $variables = array();

  if (isset($username)) {
    $variables['username'] = $username;
  }
  else {
    $variables['username'] = commitlog_account_username(
      $operation['uid'], $operation['username'], $operation['repository'], TRUE, $format
    );
  }
  // TODO: adapt for tags and branches
  $variables['id'] = theme('commitlog_commit_identifier', $operation, $format);
  $variables['repository_name'] = theme('commitlog_repository', $operation['repository'], $format);
  $variables['time'] = format_date($operation['date'], 'custom', 'H:i');

  $variables['actions'] = theme('commitlog_operation_items', $operation, $operation_items, $format);
  $variables['message'] = theme('commitlog_operation_message', $operation, $format);
  $variables['branches'] = theme('commitlog_operation_branches', $operation, $format);

  if ($operation['type'] == VERSIONCONTROL_OPERATION_COMMIT
      && versioncontrol_backend_implements($operation['repository']['vcs'], 'get_commit_statistics')) {
    $statistics = versioncontrol_get_commit_statistics($operation, $operation_items);
    $variables['statistics'] = theme('commitlog_commit_statistics', $operation, $statistics, $format);
  }

  if ($format == 'html') {
    return theme('commitlog_operation_html', $variables);
  }
  return theme('commitlog_operation_plaintext', $variables);
}

function theme_commitlog_operation_html($variables) {
  $output = '<div class="operation">';

  // TODO: we want a better title, now that operations can also be tags and branches.
  $output .= '<div class="title">';
  $output .= t('Commit !id by !name at !time in !repo:', array(
    '!id'   => $variables['id'],
    '!repo' => $variables['repository_name'],
    '!name' => $variables['username'],
    '!time' => $variables['time'],
  ));
  if (isset($variables['statistics'])) {
    $output .= ' ('. $variables['statistics'] .')';
  }
  $output .= "</div>\n"; // class "title"

  $output .= '<div class="actions">'. $variables['actions'] .'</div>'."\n";

  if (!empty($variables['message'])) {
    $output .= '<div class="description"><pre>'. $variables['message'] .'</pre></div>'."\n";
  }

  $output .= "</div>\n"; // class "commit"
  return $output;
}

function theme_commitlog_operation_plaintext($variables) {
  $output = t('Commit !id by !name at !time in !repo:', array(
    '!id'   => $variables['id'],
    '!repo' => $variables['repository_name'],
    '!name' => $variables['username'],
    '!time' => $variables['time'],
  )) ."\n\n";

  if (!empty($variables['message'])) {
    $output .= $variables['message'] ."\n\n";
  }
  $output .= $variables['actions'] ."\n";

  return $output;
}


/**
 * Return a the username of a VCS account.
 *
 * @param $uid
 *   The Drupal user id of the user. If this is 0, the corresponding
 *   Drupal user naturally can't be retrieved, with all implications for
 *   displaying the username.
 * @param $username
 *   The VCS username for the account.
 * @param $repository
 *   The repository where this account is registered.
 * @param $replace_with_drupal_username
 *   If TRUE (which is the default), this function tries to get the
 *   corresponding Drupal user for the supplied uid and returns the "real"
 *   username rather than the given one.
 *   If FALSE, the given VCS username is always returned.
 * @param $format
 *   If 'html', the username will be linked to the user page (if possible)
 *   or to the commit log page containing the user's commits.
 *   If 'plaintext', the username will be returned without markup.
 */
function commitlog_account_username($uid, $username, $repository, $replace_with_drupal_username = TRUE, $format = 'html') {
  if ($uid && $replace_with_drupal_username) {
    $user = user_load(array('uid' => $uid));

    if ($user) {
      return ($format == 'html') ? theme('username', $user) : $user->name;
    }
  }

  if ($format == 'html') {
    return l($username, 'commitlog', NULL,
             'usernames='. drupal_urlencode($username) .'&repos='. $repository['repo_id']);
  }
  return $username;
}

function theme_commitlog_repository($repository, $format = 'html') {
  if ($format == 'html') {
    return l($repository['name'], 'commitlog', NULL, 'repos='. $repository['repo_id']);
  }
  return check_plain($repository['name']);
}


function theme_commitlog_operation_location($operation, $directory_item = NULL, $format = 'html') {
  //TODO: construct directory item out of individual items.
  //$location = theme('commitlog_item', $operation['repository'], $directory_item, NULL, $format);
  /*$branches = theme('commitlog_operation_branches', $operation, $format);
  if (!empty($branches)) {
    $location = t('!branches: !directory', array(
      '!directory' => $location,
      '!branches' => $branches,
    ));
  }
  return $location;
  */
  return '[todo:commitlog_operation_location]';
}

function theme_commitlog_commit_identifier($operation, $format = 'html') {
  $id = versioncontrol_format_commit_identifier($operation);

  if ($format == 'html') {
    if ($operation['type'] == VERSIONCONTROL_OPERATION_COMMIT) {
      $url = versioncontrol_get_url_commit_view($operation);
    }
    if (!empty($url)) {
      return '<a href="'. $url .'">'. $id .'</a>';
    }
  }
  return theme('commitlog_vc_op_id', $operation['vc_op_id'], $id, $format);
}

function theme_commitlog_vc_op_id($vc_op_id, $text = NULL, $format = 'html') {
  if (!isset($text)) {
    $text = $vc_op_id;
  }
  if ($format == 'html') {
    return l($text, 'commitlog', NULL, 'id='. $vc_op_id);
  }
  return $text;
}

function theme_commitlog_operation_message($operation, $format = 'html') {
  if (empty($operation['message'])) {
    return '';
  }
  if ($format != 'html') {
    return $operation['message'];
  }
  // Link to issues whose numbers are given in the commit message.
  // TODO: rework this to utilize standard Drupal filters?
  return preg_replace('/#(\d+)\b/ie',
    "strtr('<a href=\"!url\">#\\1</a>',
      array('!url' => versioncontrol_get_url_tracker(\$operation['repository'], \\1)))",
    htmlspecialchars($operation['message'])
  );
}

function theme_commitlog_operation_branches($operation, $format = 'html') {
  return '';
  // TODO: adapt to use $operation['labels'] (including tags),
  // or rethink this function altogether.
  $branches = versioncontrol_get_commit_branches($operation); // function doesn't exist anymore

  if (empty($branches)) {
    return '';
  }
  if ($format == 'html') {
    $branch_links = array();
    foreach ($branches as $branch) {
      $branch_links[] = l($branch, 'commitlog', NULL, 'branch='. $branch);
    }
    return implode(', ', $branch_links);
  }
  return implode(', ', $branches);
}

function theme_commitlog_commit_statistics($operation, $commit_statistics, $format = 'html') {
  $lines = array();

  $lines[] = t('@line_count added', array('@line_count' => format_plural($commit_statistics['lines_added'], '1 line', '@count lines')));
  $lines[] = t('@line_count removed', array('@line_count' => format_plural($commit_statistics['lines_removed'], '1 line', '@count lines')));

  return implode(", ", $lines);
}

function theme_commitlog_operation_items($operation, $operation_items, $format = 'html') {
  if (empty($operation_items)) {
    return '';
  }

  /*$op_directory_item = versioncontrol_get_directory_item($operation);

  if (module_exists('versioncontrol_project')) {
    $project = versioncontrol_project_get_project_for_item($operation['repository'], $op_directory_item['path']);
    if (isset($project)) {
      $project_item = versioncontrol_get_parent_item(
        $operation['repository'], $op_directory_item, $project['directory']
      );
      $project_string = theme('commitlog_project', $operation['repository'], $project, $format);
    }
  }
  $directory_item = isset($project_item) ? $project_item : $op_directory_item;*/
  $directory_item_path = '/'; // temporary HACK, until we can do the least-common-denominator-dir again

  $lines = array();

  foreach ($operation_items as $path => $item) {
    if (module_exists('versioncontrol_project')) {
      // If all our items belong to the same project, don't try to find out
      // the project for this specific item.
      if (isset($project)) {
        $item_project = $project;
      }
      else {
        $item_project = versioncontrol_project_get_project_for_item(
          $operation['repository'], $item['path']
        );
      }
    }

    // Determine how the item path should be displayed.
    $offset = ($directory_item_path == '/') ? 0 : 1;
    $item_path = substr($item['path'], strlen($directory_item_path) + $offset);
    if ($item['type'] == VERSIONCONTROL_ITEM_DIRECTORY) {
      $item_path = t('!path [directory]', array('!path' => $item_path));
    }
    $item_string = theme('commitlog_item', $operation['repository'], $item, $item_path, $format);

    // See if there have been one or more previous versions of this item, and
    // make a displayable string out of those.
    if (isset($item['source_items'])) {
      $oldrev_string = theme('commitlog_item_revision',
        $operation['repository'], $item['source_items'][0], $format
      );

      $olditems = array();
      foreach ($item['source_items'] as $source_item) {
        $item_path = substr($source_item['path'], strlen($directory_item_path) + $offset);
        $olditems[] = theme('commitlog_item', $operation['repository'], $source_item, $item_path, $format);
      }
      $olditems_string = implode(', ', $olditems);
    }

    // If there is a diff to the previous version, show the appropriate link too.
    $show_diff = FALSE;
    if ($format == 'html') {
      $diff_string = theme('commitlog_diff_link', $operation, $item);
      if (!empty($diff_string)) {
        $show_diff = TRUE;
      }
    }

    // Depending on what happened to the items, make a readable string out of
    // the separate pieces of information that we've got by now.
    switch ($item['action']) {
      case VERSIONCONTROL_ACTION_ADDED:
        $action_string = t('!item (added)');
        break;
      case VERSIONCONTROL_ACTION_MODIFIED:
        $action_string = $show_diff
                         ? t('!item (modified, previous: !oldrev, !diff)')
                         : t('!item (modified, previous: !oldrev)');
        break;
      case VERSIONCONTROL_ACTION_MOVED:
        $action_string = $show_diff
                         ? t('!item (moved from !olditems, !diff)')
                         : t('!item (moved from !olditems)');
        break;
      case VERSIONCONTROL_ACTION_COPIED:
        $action_string = $show_diff
                         ? t('!item (copied from !olditems, !diff)')
                         : t('!item (copied from !olditems)');
        break;
      case VERSIONCONTROL_ACTION_MERGED:
        $action_string = $show_diff
                         ? t('!item (merged from !olditems, !diff)')
                         : t('!item (merged from !olditems)');
        break;
      case VERSIONCONTROL_ACTION_DELETED:
        $action_string = t('!path (deleted: !oldrev)');
        break;
      // case VERSIONCONTROL_ACTION_OTHER:
      //   $action_string = ???;
      //   break;
      default:
        return 'Error: action type enum value not known: '. $item['action'];
    }

    if ($format == 'html' && isset($item_project)) {
      $project_string = isset($project_string)
                        ? $project_string
                        : theme('commitlog_project', $operation['repository'], $item_project, $format);
      $action_string = t('!project: !action', array('!action' => $action_string));
    }

    $lines[] = strtr($action_string, array(
      '!project'  => $project_string,
      '!item'     => $item_string,
      '!path'     => $item_path,
      '!oldrev'   => $oldrev_string,
      '!olditems' => $olditems_string,
      '!diff'     => $diff_string,
    ));
  }

  $location = theme('commitlog_operation_location', $operation, /*TODO: $directory_item*/ NULL, $format);

  if ($format == 'html') {
    $output = '<div class="location">'. $location .'</div>'."\n";
    $output .= '<div class="items">'. theme('item_list', $lines) ."</div>\n";
    return $output;
  }
  // else: plaintext
  $output = $location ."\n";
  foreach ($lines as $key => $line) {
    $lines[$key] = '- '. $line;
  }
  $output .= implode("\n", $lines);
  return $output;
}

function theme_commitlog_item($repository, $item, $path_override = NULL, $format = 'html') {
  $backends = versioncontrol_get_backends();

  if (!isset($backends[$repository['vcs']])) {
    return '';
  }

  $has_atomic_commits = FALSE;
  $backend = $backends[$repository['vcs']];
  if (in_array(VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS, $backend['capabilities'])) {
    $has_atomic_commits = TRUE;
  }

  $path = isset($path_override) ? $path_override : $item['path'];

  // For version control systems without atomic commits, display the revision
  // next to the path. For all other ones this doesn't make sense, as there is
  // only one global revision for all items, and that one is already displayed
  // in the commit title.
  if (empty($item['revision']) || $has_atomic_commits) {
    $output = $path;
    if ($format == 'html') {
      $view_url = versioncontrol_get_url_item_view($repository, $item);
      if (!empty($view_url)) {
        $output = l($path, $view_url);
      }
    }
    return $output;
  }
  else {
    if ($format == 'html') {
      $log_url = versioncontrol_get_url_item_log_view($repository, $item);
      if (!empty($log_url)) {
        $path = l($path, $log_url);
      }
    }
    return $path .' '. theme('commitlog_item_revision', $repository, $item, $format);
  }
}

function theme_commitlog_item_revision($repository, $item, $format = 'html') {
  $revision = versioncontrol_format_item_revision($repository, $item);

  if ($format == 'html' && !empty($revision)) {
    $view_url = versioncontrol_get_url_item_view($repository, $item);
    if (!empty($view_url)) {
      $revision = l($revision, $view_url);
    }
  }
  return $revision;
}

function theme_commitlog_diff_link($operation, $item) {
  // We can only come up with a diff link if we've got a source item.
  if (empty($item['source_items'])) {
    return '';
  }
  // Also, a diff only makes sense if the item was actually modified.
  if (in_array($item['action'], array(VERSIONCONTROL_ACTION_MODIFIED, VERSIONCONTROL_ACTION_MERGED))) {
    // Ok, everything's alright, let's get that diff link.
    $diff_url = versioncontrol_get_url_diff(
      $operation['repository'], $item, $item['source_items'][0]
    );
    if (!empty($diff_url)) {
      return l(t('diff'), $diff_url);
    }
  }
  return '';
}

function theme_commitlog_project($repository, $project, $format = 'html') {
  $project_node = node_load($project['nid']);
  if ($project_node) {
    if ($format == 'html') {
      return l($project_node->title, 'node/'. $project_node->nid);
    }
    return check_plain($project_node->title);
  }
  return '';
}



function commitlog_branch_or_tag_operation($type, $op, $items, $username = NULL, $format = 'html') {
  if (isset($username)) {
    $variables['username'] = $username;
  }
  else {
    $variables['username'] = commitlog_account_username(
      $op['uid'], $op['username'], $op['repository'], TRUE, $format
    );
  }

  if ($type == 'branch') {
    $variables['name'] = l($op['branch_name'], 'commitlog', NULL, 'branches='. $op['branch_name']);
  }
  else {
    $variables['name'] = $op['tag_name'];
  }
  $variables['repository_name'] = theme('commitlog_repository', $op['repository'], $format);
  $variables['time'] = format_date($op['date'], 'custom', 'H:i');
  $variables['action'] = $op['action'];
  $variables['message'] = $op['message'];
  $variables['items'] = $items;

  $directory_item = versioncontrol_get_directory_item($op);
  $variables['directory'] = theme('commitlog_item',
    $op['repository'], $directory_item, $directory_item['path'], $format
  );

  if ($format == 'html') {
    return theme('commitlog_branch_or_tag_html', $type, $variables);
  }
  return theme('commitlog_branch_or_tag_plaintext', $type, $variables);
}

function theme_commitlog_branch_or_tag_html($type, $variables) {
  $action_text = theme('commitlog_branch_or_tag_action_message', $type, $variables, 'html');

  $output = '<div class="commit">';
  $output .= '<div class="title">';
  $output .= t('In !repo, at !time:', array(
    '!time' => $variables['time'],
    '!repo' => $variables['repository_name'],
  ));
  $output .= '<br/>'. $action_text;
  $output .= "</div>\n"; // class "title"

  if (!empty($variables['message'])) { // only for tags and non-CVS version control systems
    $output .= '<div class="description"><pre>'. $variables['message'] .'</pre></div>'."\n";
  }

  $output .= "</div>\n"; // class "commit"
  return $output;
}

function theme_commitlog_branch_or_tag_plaintext($type, $variables) {
  $action_text = theme('commitlog_branch_or_tag_action_message', $type, $variables, 'plaintext');

  $output = t('In !repo, at !time:', array(
    '!time' => $variables['time'],
    '!repo' => $variables['repository_name'],
  ));
  $output .= "\n". $action_text ."\n";

  if (!empty($variables['message'])) { // only for tags and non-CVS version control systems
    $output .= "\n". $variables['message'] ."\n";
  }

  return $output;
}

function theme_commitlog_branch_or_tag_action_message($type, $variables, $format) {
  $params = array(
    '!username' => $variables['username'],
    '!name' => $variables['name'],
    '!directory' => $variables['directory'],
    '!type' => ($type == 'branch') ? t('Branch') : t('Tag'),
  );

  // If the branch or tag has been assigned for the whole repository,
  // it doesn't make sense to mention the directory.
  if (empty($variables['items'])) {
    switch ($variables['action']) {
      case VERSIONCONTROL_ACTION_ADDED:
        return t('!type !name created by !username.', $params);
      case VERSIONCONTROL_ACTION_MOVED:
        return t('!type renamed to !name by !username.', $params);
      case VERSIONCONTROL_ACTION_DELETED:
        return t('!type !name by !username.', $params);
    }
  }

  switch ($variables['action']) {
    case VERSIONCONTROL_ACTION_ADDED:
      return t('!type !name created by !username in !directory.', $params);
    case VERSIONCONTROL_ACTION_MOVED:
      return t('!type renamed to !name by !username in !directory.', $params);
    case VERSIONCONTROL_ACTION_DELETED:
      return t('!type !name by !username in !directory.', $params);
  }
}
