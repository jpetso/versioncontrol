<?php
// $Id$
/**
 * @file
 * FakeVCS backend for Version Control API -
 * An example module illustrating how to write a VCS backend.
 *
 * Copyright 2007, 2008 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

// Update methods.
define('VERSIONCONTROL_FAKEVCS_UPDATE_CRON',   0);
define('VERSIONCONTROL_FAKEVCS_UPDATE_SCRIPT', 1);

// The admin pages.
include_once(drupal_get_path('module', 'versioncontrol_fakevcs') .'/versioncontrol_fakevcs.admin.inc');

/**
 * Implementation of hook_versioncontrol_backends().
 *
 * This function is mandatory for backends to implement.
 *
 * @return
 *   A structured array containing information about this backend, wrapped
 *   in a structured array. Array key is the unique string identifier of
 *   the backend. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   - 'name': The user-visible name of the VCS.
 *   - 'description': A short description of the backend, if possible not
 *        longer than one or two sentences.
 *   - 'capabilities': An array listing optional capabilities, in addition to
 *        the required functionality like retrieval of detailed commit
 *        information. Array values can be an arbitrary combination
 *        of VERSIONCONTROL_CAPABILITY_* values. If no additional capabilities
 *        are supported by the backend, this array will be empty.
 *   - 'flags': An array listing which tables should be managed by
 *        Version Control API instead of doing it manually in the backend.
 *        Array values can be an arbitrary combination of VERSIONCONTROL_FLAG_*
 *        values. If no array additions should be automatically managed,
 *        this array will be empty.
 */
function versioncontrol_fakevcs_versioncontrol_backends() {
  // Our example VCS is called FakeVCS, and supports all possible capabilities.

  return array(
    // The array key is up to 8 characters long, and used as unique identifier
    // for this VCS, in functions, URLs and in the database.
    'fakevcs' => array(
      // The user-visible name of the VCS.
      'name' => 'FakeVCS',

      // A short description of the VCS, if possible not longer than one or two sentences.
      'description' => t('FakeVCS is a version control system that is specifically capable in doing everything that any other version control system might ever do.'),

      // A list of optional capabilities, in addition to the required retrieval
      // of detailed commit information. All allowed values are listed below.
      'capabilities' => array(
        // Able to cancel commits if the committer lacks permissions
        // to commit to specific paths and/or branches.
        VERSIONCONTROL_CAPABILITY_COMMIT_RESTRICTIONS,

        // Able to cancel branch or tag assignments if the committer lacks
        // permissions to create/update/delete those.
        VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS,

        // Able to retrieve a file or its revision number based on a global
        // revision identifier.
        VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS,
      ),

      // An array listing which tables should be managed by Version Control API
      // instead of doing it manually in the backend.
      // All allowed values are listed below.
      'flags' => array(
        // versioncontrol_insert_repository() will automatically insert
        // array elements from $repository['[xxx]_specific'] into
        // {versioncontrol_[xxx]_repositories} and versioncontrol_get_repositories()
        // will automatically fetch it from there.
        VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES,
      ),
    ),

    // More backend entries are possible - modules probably won't need this,
    // but let's still provide the opportunity to do so, for consistency
    // with similar hooks from other modules and easier merging of the arrays.
  );
}

/**
 * Implementation of [versioncontrol_backend]_alter_repositories():
 * Add VCS specific repository data into a $repository['[xxx]_specific'] array.
 * By convention, this function only adds data in this specific element
 * and doesn't modify other parts of the repository array.
 *
 * Also, this function is optional for backend modules to implement. If you
 * don't need custom additions to the repositories, just don't implement it.
 *
 * @param $repositories
 *   The repositories for which this backend module needs to retrieve
 *   additional repository data. This is an array like the one returned by
 *   versioncontrol_get_repositories(), and even the '[xxx]_specific' arrays
 *   already exist. (If the VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES flag
 *   has been set by this module, it may even be filled with values already.)
 * @param $fakevcs_specific_constraints
 *   An array of FakeVCS specific filter constraints which were passed to
 *   versioncontrol_get_repositories(). Say, if FakeVCS supported modules like
 *   the CVS ones, the array would maybe contain a 'modules' constraint
 *   for filtering by module.
 */
function versioncontrol_fakevcs_alter_repositories(&$repositories, $fakevcs_specific_constraints = array()) {
  foreach ($repositories as $repo_id => $repository) {
    // Retrieve our own custom stuff.
    $additions = array(
      'modules' => array('drupal', 'contributions'),
    );

    // Filter out commits that don't match the given constraints.
    if (isset($fakevcs_specific_constraints['modules'])) {
      foreach ($fakevcs_specific_constraints['modules'] as $module_constraint) {
        if (!in_array($module_constraint, $additions['modules'])) {
          unset($repositories[$repo_id]);
          continue;
        }
      }
    }

    // Merge the additions into the existing commit array.
    $repositories[$repo_id]['fakevcs_specific'] = array_merge(
      $repository['fakevcs_specific'], $additions
    );
  }
}

/**
 * Implementation of [versioncontrol_backend]_get_short_revision_identifier():
 * Return a shortened version of the revision identifier, as plaintext.
 * This is used by versioncontrol_format_commit_identifier()
 * and versioncontrol_format_item_revision().
 *
 * This function is optional for VCS backends to implement. If it doesn't exist,
 * the API module's themeing functions will use a default return value.
 *
 * @param $revision
 *   The 'revision' property of a commit or item array,
 *   e.g. '12345' for Subversion or an SHA-1 hash for a distributed VCS.
 */
function versioncontrol_fakevcs_format_short_revision_identifier($revision) {
  // Suppose we're a distributed VCS backend and have an SHA-1 hash:
  // $commit['revision'] == '30581e4ec3347d1294ec05a91eec1a8588e5993c'
  // Let's return only the first 12 characters of the commit identifier,
  // like Mercurial (including hgweb) does by default.
  return substr($revision, 0, 12);
}

/**
 * Implementation of [versioncontrol_backend]_get_commit_statistics():
 * Retrieve general statistics about what happened in a single commit. For more granular
 * details about what happened in a single commit, use versioncontrol_get_commit_actions.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_commit_statistics')
 * if the particular backend actually implements it.
 *
 * @param $commit
 *   The commit to retrieve statistics about.
 * @param $commit_actions
 *   The commit actions array belonging to the above commit. Can be passed by
 *   the caller if the caller already has the actions, or can be left absent
 *   and they will be automatically obtained.
 *
 * @return
 *   A structured array containing general statistics about this commit.
 *   The array will consist of elements with the following keys:
 *
 *   - 'lines_added': Total number of lines added during this commit.
 *   - 'lines_removed': Total number of lines removed during this commit.
 *   - 'action_count': Total number of actions within this commit.
 *   - 'per_action_statistics': An array containing statistics on individual
 *        actions. Array keys are the current/new paths (just as with
 *        versioncontrol_get_commit_actions()).
 *
 *   The array values of the 'per_action_statistics' element are again
 *   structured arrays and consist of elements with the following keys:
 *
 *   - 'lines_added': Number of lines added to this item.
 *   - 'lines_removed': Number of lines removed to this item.
 */
function versioncontrol_fakevcs_get_commit_statistics($commit, $commit_actions = NULL) {
  // Assuming $commit is a single commit array that looks like this:
  $commit = array(
    'vc_op_id' => 2345,
    'type' => VERSIONCONTROL_OPERATION_COMMIT,
    'repository' => $affected_repository,
    'date' => time(),
    'uid' => $user->uid,
    'username' => 'jpetso',
    'directory' => '/',
    'message' => 'All kinds of demonstrative changes.',
    'revision' => '404', // for this commit, let's assume this is an SVN repository
  );

  // Retrieve the commit actions array if the caller didn't provide it.
  if ($commit_actions == NULL) {
    $commit_actions = versioncontrol_fakevcs_get_commit_actions($commit);
  }
  return array(
    'lines_added' => 30, // 15 + 5 + 7 + 3
    'lines_removed' => 20, // 3 + 17
    'action_count' => 8,
    'per_action_statistics' => array(
      '/trunk/contributions/modules/versioncontrol/versioncontrol.module' => array(
        'lines_added' => 15,
        'lines_removed' => 0,
      ),
      '/trunk/contributions/modules/versioncontrol/versioncontrol.install' => array(
        'lines_added' => 5,
        'lines_removed' => 3,
      ),
      '/branches/sandbox/jpetso/versioncontrol-notes.txt' => array(
        'lines_added' => 0,
        'lines_removed' => 17,
      ),
      '/trunk/contributions/modules/versioncontrol/versioncontrol.info' => array(
        'lines_added' => 0,
        'lines_removed' => 0,
      ),
      '/trunk/contributions/modules/versioncontrol/README.txt' => array(
        'lines_added' => 7,
        'lines_removed' => 0,
      ),
      '/trunk/contributions/modules/versioncontrol/versioncontrol_fakevcs/versioncontrol_fakevcs.module' => array(
        'lines_added' => 0,
        'lines_removed' => 0,
      ),
      '/branches/5.x-1.x/contributions/modules/cvslog' => array(
        'lines_added' => 3,
        'lines_removed' => 0,
      ),
      '/trunk/contributions/modules/versioncontrol/versioncontrol_fakevcs' => array(
        'lines_added' => 0,
        'lines_removed' => 0,
      ),
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_get_selected_label_from_operation():
 * Retrieve the tag or branch that applied to that item during the given
 * operation. The result of this function will be used for the selected label
 * property of the item, which is necessary to preserve the item state
 * throughout navigational API functions.
 *
 * This function is mandatory for backends to implement.
 *
 * @param $operation
 *   A single operation array to which the item belongs, like the ones returned
 *   by versioncontrol_get_operations(). Specifically, $operation contains the
 *   'labels' element which should probably be reused by this function.
 * @param $target_item
 *   The item revision for which the label should be retrieved.
 *
 * @return
 *   NULL if the given item does not belong to any label or if the appropriate
 *   label cannot be retrieved. Otherwise a label array is returned, consisting
 *   of the following elements:
 *
 *   - 'name': The branch or tag name (a string).
 *   - 'type': Whether this label is a branch (indicated by the
 *        VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *        (VERSIONCONTROL_OPERATION_TAG).
 *
 *   In case the label array also contains the 'label_id' element (which
 *   happens when it's copied from the $operation['labels'] array) there will
 *   be a small performance improvement as the label doesn't need to be
 *   compared to and loaded from the database anymore.
 */
function versioncontrol_fakevcs_get_selected_label_from_operation($operation, $target_item) {
  // How CVS and many other version control systems will probably do it,
  // as they have exactly one label assigned to each operation.
  return $operation['labels'][0];

  // If an operation - or more specifically, a commit - applies to multiple
  // branches and/or tags (as can happen in SVN, for example), then the correct
  // label for each item has to be determined.
}

/**
 * Implementation of [versioncontrol_backend]_get_selected_label_from_other_item():
 * Retrieve a valid label (tag or branch) for a new @p $target_item that is
 * (hopefully) similar or related to that of the given @p $other_item which
 * already has a selected label assigned. If the backend cannot find a related
 * label, return any valid label. The result of this function will be used for
 * the selected label property of each item, which is necessary to preserve the
 * item state throughout navigational API functions.
 *
 * This function is mandatory for backends to implement.
 *
 * @param $repository
 *   The repository array (like returned by versioncontrol_get_repository())
 *   of the repository which contains both the source and the successor item.
 * @param $target_item
 *   The item revision for which the label should be retrieved.
 * @param $other_item
 *   The item revision that the selected label should be derived from.
 *   For example, if @p $other_item in a CVS repository is at revision
 *   '1.5.2.1' which is on the 'DRUPAL-6--1' branch, and the @p $target_item
 *   is at revision '1.5' (its predecessor) which is present on both the
 *   'DRUPAL-6--1' and 'HEAD' branches, then this function should return a
 *   label array for the 'DRUPAL-6--1' branch.
 * @param $other_item_tags
 *   An array with a simple list of strings that describe properties of the
 *   @p $other_item, in relation to the @p $target_item. You can use those
 *   in order to make assumptions so that the selected label can be retrieved
 *   more accurately or with better performance. Version Control API passes a
 *   list that may contain zero or more of the following tags:
 *
 *   - 'source_item': The @p $other_item is a predecessor of the
 *        @p $target_item - same entity, but in an earlier revision and
 *        potentially with a different path, too (only if the backend supports
 *        item moves).
 *   - 'successor_item': The @p $other_item is a successor of the
 *        @p $target_item - same entity, but in a later revision and
 *        potentially with a different path, too (only if the backend supports
 *        item moves).
 *   - 'same_revision': The @p $other_item is at the same (global) revision
 *        as the @p $target_item. Specifically meant for backends whose
 *        version control systems don't support atomic commits.
 *
 * @return
 *   NULL if the given item does not belong to any label or if an appropriate
 *   label cannot be retrieved. Otherwise a label array is returned, consisting
 *   of the following elements:
 *
 *   - 'name': The branch or tag name (a string).
 *   - 'type': Whether this label is a branch (indicated by the
 *        VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *        (VERSIONCONTROL_OPERATION_TAG).
 *
 *   In case the label array also contains the 'label_id' element (which
 *   happens when it's copied from the $operation['labels'] array) there will
 *   be a small performance improvement as the label doesn't need to be
 *   compared to and loaded from the database anymore.
 */
function versioncontrol_fakevcs_get_selected_label_from_other_item($repository, $target_item, &$other_item, $other_item_tags = array()) {
  // First up, optimizations - maybe we can do without the generic
  // "label transfer" code from further down and use assumptions instead.

  // Let's assume for FakeVCS repositories that if an item wears a label, then
  // an item at another path but with the same (file-level) revision can also
  // wear that same label. That is the case with some version control systems
  // (e.g. Git, Mercurial, Bazaar) but might not be the case with others
  // (CVS for its lack of global revision identifiers, SVN for its use of
  // directory structure as tag/branch identifiers).
  if ($item['revision'] == $other_item['revision']) {
    return versioncontrol_get_item_selected_label($repository, $other_item);
  }

  // If the $other_item is a successor item on a branch, some version control
  // systems (like CVS) can guarantee that the $target_item, the predecessor,
  // is always on the same branch. So no need for database queries, yay.
  if (in_array('successor_item', $other_item_tags)) {
    $label = versioncontrol_get_item_selected_label($repository, $other_item);

    if (isset($label['type']) && $label['type'] == VERSIONCONTROL_OPERATION_BRANCH) {
      return $label;
    }
  }

  // Otherwise we might not be able to derive the $target_item's label,
  // in which case we need to fall back to the database or a VCS invocation.
  // For example, something like this.
  if (versioncontrol_fetch_item_revision_id($repository, $target_item)) {
    $constraints = array(
      'item_revision_id' => array($target_item['item_revision_id']),
    );
    $commit_operations = versioncontrol_get_commit_operations($constraints);

    if (!empty($commit_operations)) { // yo, found the associated commit!
      // Code taken from the CVS backend, which only assigns a single branch
      // to any given commit operation, so it can just take the first one.
      $commit_operation = reset($commit_operations); // first (only) element
      return $commit_operation['labels'][0];
    }
  }

  // (You can even do more attempts if you want to, like trying to ask
  // the VCS itself. Or maybe not, depends on your motivation and the
  // VCS's capabilities.)

  // No label could be retrieved by looking at the other item, sorry.
  return NULL;
}

/**
 * Implementation of [vcs_backend]_get_item():
 * Try to retrieve a given item in a repository.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_item')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $path
 *   The path of the requested item.
 * @param $revision
 *   A specific revision for the requested item (as interpreted by the
 *   VCS backend), or NULL if any revision is good enough - preferably,
 *   the most recent one.
 *
 * @return
 *   If the item with the given path and revision cannot be retrieved, NULL is
 *   returned. Otherwise the result of the backend function is a structured
 *   array with the elements 'item' and 'selected_label', making up the whole
 *   picture.
 *
 *   - 'item': An item array, consisting of the following elements:
 *
 *        - 'type': Specifies the item type, which is either
 *             VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY for
 *             items that still exist, or VERSIONCONTROL_ITEM_FILE_DELETED
 *             respectively VERSIONCONTROL_ITEM_DIRECTORY_DELETED for items
 *             that have been removed.
 *        - 'path': The path of the item at the specific revision.
 *        - 'revision': The currently selected (file-level) revision of the
 *             item. If there is no such revision (which may be the case for
 *             directory items) then the 'revision' element is an empty string.
 *
 *        If the returned item is already present in the database, the
 *        'item_revision_id' database identifier might also be filled in
 *        (optionally, depending on the VCS backend).
 *
 *   - 'selected_label':
 *        In case no branch or tag applies to that item or could not be
 *        retrieved for whatever reasons, the selected label can also be NULL.
 *        Otherwise, it's a label array describing the selected label, with the
 *        following keys:
 *
 *        - 'name': The branch or tag name (a string).
 *        - 'type': Whether this label is a branch (indicated by the
 *             VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *             (VERSIONCONTROL_OPERATION_TAG).
 *
 *        In case the label array also contains the 'label_id' element (which
 *        happens when it's copied from the $operation['labels'] array) there
 *        will be a small performance improvement as the label doesn't need to
 *        be compared to and loaded from the database anymore.
 */
function versioncontrol_fakevcs_get_item($repository, $path, $revision = '') {
  // Slightly adapted version of the SVN backend's implementation.
  if (empty($revision)) {
    $revision = 'HEAD';
  }
  // Wherever you get your item info from.
  $info = fakevcs_item_info($repository, $path, $revision);

  $item = array(
    'path' => $path,
    'revision' => $info['rev'],
    'type' => ($info['rev'] == 'dir')
              ? VERSIONCONTROL_ITEM_DIRECTORY
              : VERSIONCONTROL_ITEM_FILE,
  );
  return array('item' => $item, 'selected_label' => NULL);
}

/**
 * Implementation of [vcs_backend]_get_parent_item():
 * Retrieve the parent (directory) item of a given item.
 *
 * This function is optional for VCS backends to implement. If it doesn't exist,
 * the API module will use the default implementation that just returns the
 * original item with a changed path.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose parent should be retrieved.
 * @param $parent_path
 *   NULL if the direct parent of the given item should be retrieved,
 *   or a parent path that is further up the directory tree.
 *
 * @return
 *   The parent directory item at the same revision as the given item.
 *   If $parent_path is not set and the item is already the topmost one
 *   in the repository, the item is returned as is. It also stays the same
 *   if $parent_path is given and the same as the path of the given item.
 *   If the given directory path does not correspond to a parent item,
 *   NULL is returned.
 */
function versioncontrol_fakevcs_get_parent_item($repository, $item, $parent_path) {
  // This is the default implementation, don't implement this function unless
  // you need to modify more item properties.
  if (!isset($parent_path)) {
    $item['path'] = dirname($item['path']);
    return $item;
  }
  else if (strpos($item['path'] .'/', $parent_path .'/') !== FALSE) {
    $item['path'] = $parent_path;
    return $item;
  }
  return NULL;
}


/**
 * Implementation of [versioncontrol_backend]_get_all_item_branches():
 * Retrieve all branches that exist for the given item, and how this item
 * is named there. The main branch ('HEAD', 'trunk', 'master' or however it is
 * called in the respective VCS) is also included in the result.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_all_item_branches')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose set of branches should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $branch1_name => $branch1_item,
 *       $branch2_name => $branch2_item,
 *       ...
 *     ).
 *
 *   The corresponding item values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was last changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier of the respective
 *        version control system.)
 *
 *   An empty array is returned if there are no branches for this item.
 *   NULL is returned if the given item is not inside the repository at the
 *   time of 'revision'.
 */
function versioncontrol_fakevcs_get_all_item_branches($repository, $item) {
  // How CVS would probably do it, if for example
  // $item['path'] == '/contributions/modules/versioncontrol/versioncontrol.module':
  return array(
    'HEAD' => array(
      'type'     => VERSIONCONTROL_ITEM_FILE,
      'path'     => '/contributions/modules/versioncontrol/versioncontrol.module',
      'revision' => '1.23',
      'fakevcs_specific' => array('selected_branch_name' => 'HEAD'),
    ),
    'DRUPAL-5--1' => array(
      'type'     => VERSIONCONTROL_ITEM_FILE,
      'path'     => '/contributions/modules/versioncontrol/versioncontrol.module',
      'revision' => '1.23.2.42',
      'fakevcs_specific' => array('selected_branch_name' => 'DRUPAL-5--1'),
    ),
  );
  // How SVN could also do it, if for example
  // $item['path'] == '/trunk/contributions/modules/versioncontrol':
  return array(
    'trunk' => array(
      'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
      'path'     => '/trunk/contributions/modules/versioncontrol',
      'revision' => '23',
    ),
    '5.x-1.x' => array(
      'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
      'path'     => '/branches/5.x-1.x/contributions/modules/versioncontrol',
      'revision' => '42',
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_get_all_item_tags():
 * Retrieve all tags that exist for the given item $path, and how this item
 * is named there.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_all_item_tags')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose history should be retrieved.
 *
 * @return
 *   A structured array that looks like
 *     array(
 *       $tag1_name => $tag1_item,
 *       $tag2_name => $tag2_item,
 *       ...
 *     ).
 *
 *   The corresponding item values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was last changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier of the respective
 *        version control system.)
 *
 *   An empty array is returned if there are no tags for this item.
 *   NULL is returned if the given item is not inside the repository at the
 *   time of 'revision'.
 */
function versioncontrol_fakevcs_get_all_item_tags($repository, $item) {
  // How CVS would probably do it, if for example
  // $item['path'] == '/contributions/modules/versioncontrol':
  return array(
    'DRUPAL-5--1-1' => array(
      'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
      'path'     => '/contributions/modules/versioncontrol',
      'revision' => '', // Right, it's a directory in CVS -> unversioned.
                        // Files of course would indeed get a 'revision' entry.
      'fakevcs_specific' => array('tag' => 'DRUPAL-5--1-1'),
    ),
    'DRUPAL-5--1-2' => array(
      'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
      'path'     => '/contributions/modules/versioncontrol',
      'revision' => '',
      'fakevcs_specific' => array('tag' => 'DRUPAL-5--1-2'),
    ),
  );

  // How SVN could also do it, if for example
  // $item['path'] == '/tags/5.x-1.2/contributions/modules/versioncontrol/versioncontrol.module':
  return array(
    '5.x-1.1' => array(
      'type'     => VERSIONCONTROL_ITEM_FILE,
      'path'     => '/tags/5.x-1.1/contributions/modules/versioncontrol/versioncontrol.module',
      'revision' => '15',
    ),
    '5.x-1.2' => array(
      'type'     => VERSIONCONTROL_ITEM_FILE,
      'path'     => '/tags/5.x-1.2/contributions/modules/versioncontrol/versioncontrol.module',
      'revision' => '16',
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_get_item_history():
 * Retrieve the revisions where the given item has been changed,
 * in reverse chronological order.
 *
 * Only direct descendants or predecessors of this item will be retrieved.
 * That means that history of the same item in a different (parallel) branch
 * will not be returned, except if the given state of the item was moved/copied
 * from there or goes back there in a more recent revision. In short, you'll
 * not get "1.7" and "1.2.2.4" items side by side if it doesn't make sense.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_item_history')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose history should be retrieved.
 *
 * @return
 *   An array containing the exact details of all item changes. Each element
 *   of the array is a structured array consisting of elements with the
 *   following keys:
 *
 *   - 'action': Specifies how the item was modified.
 *        One of the predefined VERSIONCONTROL_ACTION_* values.
 *   - 'modified': Boolean value, specifies if a file was modified in addition
 *        to the other action in the 'action' element of the array.
 *        Only exists for the VERSIONCONTROL_ACTION_MOVED
 *        and VERSIONCONTROL_ACTION_COPIED actions.
 *   - 'current item': The updated state of the modified item.
 *        Exists for all actions except VERSIONCONTROL_ACTION_DELETED.
 *   - 'source items': An array with the previous state(s) of the modified item.
 *        Exists for all actions except VERSIONCONTROL_ACTION_ADDED.
 *
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision.
 */
function versioncontrol_get_item_history($repository, $item) {
  // Assuming $item is an item array that looks like this:
  $item = array(
    'type'     => VERSIONCONTROL_ITEM_FILE,
    'path'     => '/trunk/contributions/modules/versioncontrol/versioncontrol.info',
    'revision' => '666',
  );
  // and $repository is some SVN repository.

  return array(
    array(
      'action'       => VERSIONCONTROL_ACTION_MOVED,
      'current item' => array(
        'type'         => VERSIONCONTROL_ITEM_FILE,
        'path'         => '/trunk/contributions/modules/versioncontrol/versioncontrol.info',
        'revision'     => '404',
      ),
      'source items' => array(
        array(
          'type'       => VERSIONCONTROL_ITEM_FILE,
          'revision'   => '42',
          'path'       => '/branches/sandbox/jpetso/versioncontrol.info',
        ),
      ),
      'modified'     => FALSE,
    ),
    array(
      'action'       => VERSIONCONTROL_ACTION_ADDED,
      'current item' => array(
        'type'         => VERSIONCONTROL_ITEM_FILE,
        'revision'     => '42',
        'path'         => '/branches/sandbox/jpetso/versioncontrol.info',
      ),
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_get_directory_contents():
 * Retrieve the set of files and directories that exist at a specified revision
 * in the given directory inside the repository.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_directory_contents')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the directory item is located in.
 * @param $directory_item
 *   The parent item of the the items that should be listed.
 * @param $recursive
 *   If FALSE, only the direct children of $path will be retrieved.
 *   If TRUE, you'll get every single descendant of $path.
 *
 * @return
 *   An array containing the exact details of which items have been inside the
 *   directory at the revision of the directory item, including the directory
 *   item itself. Array keys are the current/new paths. The corresponding
 *   values are again structured arrays, each with a pair of 'item' and
 *   'selected_label' elements as follows.
 *
 *   - 'item': An item array, consisting of the following elements:
 *
 *        - 'type': Specifies the item type, which is either
 *             VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY for
 *             items that still exist, or VERSIONCONTROL_ITEM_FILE_DELETED
 *             respectively VERSIONCONTROL_ITEM_DIRECTORY_DELETED for items
 *             that have been removed.
 *        - 'path': The path of the item at the specific revision.
 *        - 'revision': The currently selected (file-level) revision of the
 *             item. If there is no such revision (which may be the case for
 *             directory items) then the 'revision' element is an empty string.
 *
 *        If the returned item is already present in the database, the
 *        'item_revision_id' database identifier might also be filled in
 *        (optionally, depending on the VCS backend).
 *
 *   - 'selected_label':
 *        In case no branch or tag applies to that item or could not be
 *        retrieved for whatever reasons, the selected label can also be NULL.
 *        Otherwise, it's a label array describing the selected label, with the
 *        following keys:
 *
 *        - 'name': The branch or tag name (a string).
 *        - 'type': Whether this label is a branch (indicated by the
 *             VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *             (VERSIONCONTROL_OPERATION_TAG).
 *
 *        In case the label array also contains the 'label_id' element (which
 *        happens when it's copied from the $operation['labels'] array) there
 *        will be a small performance improvement as the label doesn't need to
 *        be compared to and loaded from the database anymore.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision.
 *   The API module ensures that the passed item is a directory item.
 */
function versioncontrol_fakevcs_get_directory_contents($repository, $directory_item, $recursive = FALSE) {
  // Assuming $parent_item is an item array that looks like this:
  $directory_item = array(
    'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
    'path'     => '/trunk/contributions/modules/versioncontrol',
    'revision' => '666',
  );
  // $repository is some SVN repository and $recursive == FALSE. SVN without
  // branch/tag emulation can return NULL for all the selected labels.

  return array(
    '/trunk/contributions/modules/versioncontrol' => array(
      'item' => array( // == rtrim($path, '/')
        'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
        'path'      => '/trunk/contributions/modules/versioncontrol',
        'revision'  => '502',
      ),
      'selected_label' => NULL,
    )
    '/trunk/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'item' => array(
        'type'      => VERSIONCONTROL_ITEM_FILE,
        'path'      => '/trunk/contributions/modules/versioncontrol/versioncontrol.module',
        'revision'  => '502',
      ),
      'selected_label' => NULL,
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol.info' => array(
      'item' => array(
        'type'      => VERSIONCONTROL_ITEM_FILE,
        'path'      => '/trunk/contributions/modules/versioncontrol/versioncontrol.info',
        'revision'  => '404',
      ),
      'selected_label' => NULL,
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol.install' => array(
      'item' => array(
        'type'      => VERSIONCONTROL_ITEM_FILE,
        'path'      => '/trunk/contributions/modules/versioncontrol/versioncontrol.install',
        'revision'  => '404',
      ),
      'selected_label' => NULL,
    ),
    '/trunk/contributions/modules/versioncontrol/README.txt' => array(
      'item' => array(
        'type'      => VERSIONCONTROL_ITEM_FILE,
        'path'      => '/trunk/contributions/modules/versioncontrol/README.txt',
        'revision'  => '404',
      ),
      'selected_label' => NULL,
    ),
    '/trunk/contributions/modules/versioncontrol/versioncontrol_fakevcs' => array(
      'item' => array(
        'type'      => VERSIONCONTROL_ITEM_DIRECTORY,
        'path'      => '/trunk/contributions/modules/versioncontrol/versioncontrol_fakevcs.txt',
        'revision'  => '497',
      ),
      'selected_label' => NULL,
    ),
  );

  // Or the same thing in CVS - note that 'revision' is an empty string
  // for directories, as CVS doesn't support versioned directories.
  $directory_item = array(
    'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
    'path'     => '/contributions/modules/versioncontrol',
    'revision' => '',
  );
  // $repository is some CVS repository and $recursive == TRUE.
  // For the purpose of example, we use the same label as the directory item.
  // (Real-life usage might or might not require more correctness checks.)
  $selected_label = versioncontrol_get_selected_label($directory_item);

  return array(
    '/contributions/modules/versioncontrol' => array(
      'item' => array( // == rtrim($path, '/')
        'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
        'path'     => '/contributions/modules/versioncontrol',
        'revision' => '', // CVS doesn't track directory-level revisions
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/versioncontrol.module' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE,
        'path'     => '/contributions/modules/versioncontrol/versioncontrol.module',
        'revision' => '1.19',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/versioncontrol.info' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE,
        'path'     => '/contributions/modules/versioncontrol/versioncontrol.info',
        'revision' => '1.1',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/versioncontrol.install' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE,
        'path'     => '/contributions/modules/versioncontrol/versioncontrol.install',
        'revision' => '1.5',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/README.txt' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE,
        'path'     => '/contributions/modules/versioncontrol/README.txt',
        'revision' => '1.1',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/fakevcs_backend' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
        'path'     => '/contributions/modules/versioncontrol/fakevcs_backend',
        'revision' => '',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/fakevcs_backend/fakevcs_backend.module' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE_DELETED, // only for non-atomic-commit VCSs (= CVS)
        'path'     => '/contributions/modules/versioncontrol/fakevcs_backend/fakevcs_backend.module',
        'revision' => '1.11', // last existing version
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/versioncontrol_fakevcs' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_DIRECTORY,
        'path'     => '/contributions/modules/versioncontrol/versioncontrol_fakevcs',
        'revision' => '',
      ),
      'selected_label' => $selected_label,
    ),
    '/contributions/modules/versioncontrol/versioncontrol_fakevcs/versioncontrol_fakevcs.module' => array(
      'item' => array(
        'type'     => VERSIONCONTROL_ITEM_FILE,
        'path'     => '/contributions/modules/versioncontrol/versioncontrol_fakevcs/versioncontrol_fakevcs.module',
        'revision' => '1.2',
      ),
      'selected_label' => $selected_label,
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_open_file_handle():
 * Retrieve a copy of the contents of a given item in the repository.
 * (You won't get the original because repositories can often be remote.)
 *
 * If a file could not be created, backends should take care to delete any
 * remaining temporary files before returning.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_file_copy')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the file item is located in.
 * @param $file_item
 *   The file item whose contents should be retrieved.
 * @param $destination
 *   The path where the copied file should be written to.
 *
 * @return
 *   TRUE if the file was successfully created, FALSE if not.
 *   The API module ensures that the passed item is a file item.
 */
function versioncontrol_fakevcs_get_file_copy($repository, $file_item, $destination) {
  exec('fakevcs cat '. $repository['root'] . $file_item['path'] .' > '. $destination,
       $output, $return_code);

  if ($return_code != 0) {
    @unlink($destination);
    return FALSE;
  }
  return TRUE;
}

/**
 * Implementation of [versioncontrol_backend]_get_file_annotation():
 * Retrieve an array where each element represents a single line of the
 * given file in the specified commit, annotated with the committer who last
 * modified that line. Note that annotations are generally a quite slow
 * operation, so expect this function to take a bit more time as well.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_file_annotation')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the file item is located in.
 * @param $file_item
 *   The file item whose annotation should be retrieved.
 *
 * @return
 *   A structured array that consists of one element per line, with
 *   line numbers as keys (starting from 1) and a structured array as values,
 *   where each of them consists of elements with the following keys:
 *
 *   - 'username': The system specific VCS username of the last committer.
 *   - 'line': The contents of the line, without linebreak characters.
 *
 *   NULL is returned if the given item is not under version control,
 *   or was not under version control at the time of the given revision,
 *   or if it is marked as binary file.
 *   The API module ensures that the passed item is a file item.
 */
function versioncontrol_fakevcs_get_file_annotation($repository, $file_item) {
  // In case the file is marked as text file:
  return array(
    1 => array(
      'username' => 'dries',
      'line'     => '<?php',
    ),
    2 => array(
      'username' => 'jpetso',
      'line'     => '// $Id$',
    ),
  );
}



/**
 * Implementation of [versioncontrol_backend]_commit():
 * Manage (insert or delete) additional commit data in the database.
 *
 * This function is optional for backend modules to implement. If you don't
 * need custom repository data (or you let the Version Control API manage it),
 * just don't implement it.
 *
 * @param $op
 *   Either 'insert' when the commit is in the process of being created,
 *   or 'delete' if it will be deleted after this function has been called.
 * @param $commit
 *   A single commit array, like the ones returned
 *   by versioncontrol_get_commits().
 * @param $commit_actions
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. The structure of this array is the same as
 *   the return value of versioncontrol_get_commit_actions().
 */
// TODO: port to the 2.x function signature and to an example that still makes sense.
function versioncontrol_fakevcs_commit($op, $commit, $commit_actions) {
  // If nothing has to be stored in addition to the commit info that
  // versioncontrol_insert_commit() stores by itself, this function
  // doesn't have to be implemented by the backend.
  // If you've got stuff like file tables or whatever, it may come in handy.
  switch ($op) {
    case 'insert':
      foreach ($commit_actions as $path => $action) {
        $revision = '';
        $source_revision = '';

        // If available, get item type and revision from the contained items.
        if (isset($action['current item'])) {
          $type = $action['current item']['type'];
          $revision = $action['current item']['revision'];
        }
        else {
          $type = $action['source items'][0]['type'];
          $source_revision = $action['source items'][0]['revision'];
        }

        db_query(
          "INSERT INTO {versioncontrol_fakevcs_item_revisions}
          (vc_op_id, type, path, revision, action, source_revision)
          VALUES (%d, %d, '%s', '%s', %d, %d)",
          $commit['vc_op_id'], $type, $path, $revision, $action['action'],
          $source_revision
        );
      }
      break;

    case 'delete':
      db_query('DELETE FROM {versioncontrol_fakevcs_item_revisions}
                WHERE vc_op_id = %d', $commit['vc_op_id']);
      break;
  }
}

/**
 * Implementation of [versioncontrol_backend]_account():
 * Manage (insert, update or delete) additional FakeVCS user account data
 * in the database.
 *
 * This function is optional for backend modules to implement. If you don't
 * need custom repository data (or you let the Version Control API manage it),
 * just don't implement it.
 *
 * @param $op
 *   Either 'insert' when the account is in the process of being created,
 *   or 'update' when username or VCS specific data change,
 *   or 'delete' if it will be deleted after this function has been called.
 * @param $uid
 *   The Drupal user id corresponding to the VCS account.
 * @param $username
 *   The VCS specific username (a string).
 * @param $repository
 *   The repository where the user has its VCS account.
 * @param $additional_data
 *   An array of additional author information.
 */
function versioncontrol_fakevcs_account($op, $uid, $username, $repository, $additional_data = array()) {
  $fakevcs_specific = $additional_data['fakevcs_specific'];

  switch ($op) {
    case 'insert':
      if (!isset($fakevcs_specific) || !isset($fakevcs_specific['password'])) {
        drupal_set_message(t('Error: no FakeVCS password given on account creation!'), 'error');
        return;
      }
      db_query("INSERT INTO {versioncontrol_fakevcs_accounts}
                (uid, repo_id, password)
                VALUES (%d, %d, '%s')",
                $uid, $repository['repo_id'], $fakevcs_specific['password']);
      break;

    case 'update':
      if (!isset($fakevcs_specific) || !isset($fakevcs_specific['password'])) {
        return; // the user didn't update the password in the process.
      }
      db_query("UPDATE {versioncontrol_fakevcs_accounts}
                SET password = '%s'
                WHERE uid = %d AND repo_id = %d",
                $fakevcs_specific['password'], $uid, $repository['repo_id']);

      if (!user_access('administer version control systems')) {
        // Admins get "The account has been updated successfully" anyways.
        drupal_set_message(t('The FakeVCS password has been updated successfully.'));
      }
      break;

    case 'delete':
      db_query('DELETE FROM {versioncontrol_fakevcs_accounts}
                WHERE uid = %d AND repo_id = %d',
                $uid, $repository['repo_id']);
      break;
  }
}

/**
 * Implementation of [versioncontrol_backend]_repository():
 * Manage (insert, update or delete) additional FakeVCS repository data
 * in the database.
 *
 * This function is optional for backend modules to implement. If you don't
 * need custom repository data (or you let the Version Control API manage it),
 * just don't implement it.
 *
 * @param $op
 *   Either 'insert' when the repository has just been created, or 'update'
 *   when repository name, root, URL backend or module specific data change,
 *   or 'delete' if it will be deleted after this function has been called.
 *
 * @param $repository
 *   The repository array containing the repository. It's a single
 *   repository array like the one returned by versioncontrol_get_repository(),
 *   so it consists of the following elements:
 *
 *   - 'repo_id': The unique repository id.
 *   - 'name': The user-visible name of the repository.
 *   - 'vcs': The unique string identifier of the version control system
 *        that powers this repository.
 *   - 'root': The root directory of the repository. In most cases,
 *        this will be a local directory (e.g. '/var/repos/drupal'),
 *        but it may also be some specialized string for remote repository
 *        access. How this string may look like depends on the backend.
 *   - 'authorization_method': The string identifier of the repository's
 *        authorization method, that is, how users may register accounts
 *        in this repository. Modules can provide their own methods
 *        by implementing hook_versioncontrol_authorization_methods().
 *   - 'url_backend': The prefix (excluding the trailing underscore)
 *        for URL backend retrieval functions.
 *   - '[xxx]_specific': An array of VCS specific additional repository
 *        information. How this array looks like is defined by the
 *        corresponding backend module (versioncontrol_[xxx]).
 */
function versioncontrol_fakevcs_repository($op, $repository) {
  if ($op == 'delete') {
    db_query('DELETE FROM {versioncontrol_fakevcs_repository_ponies}
              WHERE repo_id = %d', $repository['repo_id']);
  }
}


/**
 * Implementation of [vcs_backend]_import_accounts():
 * Import accounts into a repository, given text data from the accounts file.
 * No accounts are deleted, new accounts are inserted, and existing accounts
 * are updated with imported ones.
 *
 * This function is optional for backend modules to implement. If it's not
 * implemented, the user will simply not be offered import functionality.
 *
 * @param $repository
 *   The repository where the accounts will be imported.
 * @param $data
 *   The contents of the "account data" text area where the user has to
 *   enter/copy the contents of the version control system's accounts file.
 */
function versioncontrol_fakevcs_import_accounts($repository, $data) {
  $accounts = versioncontrol_fakevcs_parse_account_data($repository, $data);

  foreach ($accounts as $account) {
    $additional_data = array(
      'fakevcs_specific' => array('password' => $password),
    );
    $username = $account['username'];
    $uid = versioncontrol_get_account_uid_for_username($repository['repo_id'], $username, TRUE);

    if (isset($uid)) {
      versioncontrol_update_account($repository, $uid, $username, $additional_data);
      $names[] = t('updated !username', array('!username' => $username));
    }
    else {
      $uid = db_result(db_query("SELECT uid FROM {users} WHERE name = '%s'", $username));
      if ($uid) {
        versioncontrol_insert_account($repository, $uid, $username, $additional_data);
        $names[] = t('added !username', array('!username' => $username));
      }
      else {
        $names[] = t('didn\'t add !username (no matching Drupal username exists)',
                      array('!username' => $username));
      }
    }
  }
}

/**
 * Implementation of [vcs_backend]_export_accounts():
 * Export accounts of a repository to text data that is suitable for
 * copying to the version control system's accounts file.
 *
 * This function is optional for backend modules to implement. If it's not
 * implemented, the user will simply not be offered export functionality.
 *
 * @param $repository
 *   The repository whose accounts will be exported.
 * @param $accounts
 *   The list (array) of accounts that should be exported, given in the same
 *   format as the return value of versioncontrol_get_accounts().
 *   All accounts in this list are from the above repository.
 *
 * @return
 *   The exported textual representation of the account list.
 */
function versioncontrol_fakevcs_export_accounts($repository, $accounts) {
  if (empty($accounts)) {
    return '# '. t('no user accounts available to export');
  }
  $accounts_flat = array();
  $uid_constraints = array();
  $params = array($repository['repo_id']);

  foreach ($accounts as $uid => $usernames_per_repository) {
    foreach ($usernames_per_repository as $repo_id => $username) {
      $accounts_flat[$uid] = array('uid' => $uid, 'username' => $username);
      $uid_constraints[] = 'uid = %d';
      $params[] = $uid;
    }
  }

  $result = db_query('SELECT uid, password FROM {versioncontrol_fakevcs_accounts}
                      WHERE repo_id = %d
                       AND ('. implode(' OR ', $uid_constraints) .')',
                      $params);
  while ($account = db_fetch_object($result)) {
    $accounts_flat[$account->uid]['password'] = $account->password;
  }

  $data = '';
  foreach ($accounts_flat as $uid => $account) {
    $data .= '# '. url('user/'. $uid, NULL, NULL, TRUE) ."\n";
    $data .= $account['username'] .':'. $account['password'] ."\n";
  }
  return $data;
}
