<?php
// $Id$
/**
 * @file
 * Version Control API - An interface to version control systems
 * whose functionality is provided by pluggable back-end modules.
 *
 * Copyright 2006 by Karthik ("Zen", http://drupal.org/user/21209)
 * Copyright 2006, 2007 by Derek Wright ("dww", http://drupal.org/user/46549)
 * Copyright 2007 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

/**
 * Implementation of hook_install().
 */
function versioncontrol_install() {
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      db_query("CREATE TABLE {versioncontrol_operations} (
        vc_op_id int unsigned NOT NULL default 0,
        type tinyint unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        date bigint NOT NULL default 0,
        uid int unsigned NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        message text,
        PRIMARY KEY (vc_op_id),
        KEY type (type),
        KEY repo_id (repo_id),
        KEY date (date),
        KEY uid (uid),
        KEY username (username),
        KEY revision (revision)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_operation_labels} (
        vc_op_id int unsigned NOT NULL default 0,
        label_id int unsigned NOT NULL default 0,
        action tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (vc_op_id, label_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_labels} (
        label_id int unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        name varchar(255) NOT NULL default '',
        type tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (label_id),
        UNIQUE KEY (repo_id, name, type)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_operation_items} (
        vc_op_id int unsigned NOT NULL default 0,
        item_revision_id int unsigned NOT NULL default 0,
        PRIMARY KEY (vc_op_id, item_revision_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_source_items} (
        item_revision_id int unsigned NOT NULL default 0,
        source_item_revision_id int unsigned NOT NULL default 0,
        action tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (item_revision_id, source_item_revision_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_item_revisions} (
        item_revision_id int unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        path varchar(255) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        type tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (item_revision_id),
        UNIQUE KEY (repo_id, path),
        KEY revision (revision)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_repositories} (
        repo_id int unsigned NOT NULL default 0,
        name varchar(255) NOT NULL default '',
        vcs varchar(8) NOT NULL default '',
        root varchar(255) NOT NULL default '',
        authorization_method varchar(64) NOT NULL default '',
        url_backend varchar(64) NOT NULL default '',
        PRIMARY KEY (repo_id),
        UNIQUE KEY name (name)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_repository_urls} (
        repo_id int unsigned NOT NULL default 0,
        commit_view varchar(255) NOT NULL default '',
        file_log_view varchar(255) NOT NULL default '',
        file_view varchar(255) NOT NULL default '',
        directory_view varchar(255) NOT NULL default '',
        diff varchar(255) NOT NULL default '',
        tracker varchar(255) NOT NULL default '',
        PRIMARY KEY (repo_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_repository_metadata} (
        repo_id int unsigned NOT NULL default 0,
        weight smallint NOT NULL default 0,
        registration_message text,
        PRIMARY KEY (repo_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_accounts} (
        uid int unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        PRIMARY KEY (uid, repo_id),
        UNIQUE KEY (repo_id, username)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");
      break;

    case 'pgsql':
      db_query("CREATE TABLE {versioncontrol_operations} (
        vc_op_id int NOT NULL default 0,
        type smallint NOT NULL default 0,
        repo_id int NOT NULL default 0,
        date bigint NOT NULL default 0,
        uid int NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        message text,
        PRIMARY KEY (vc_op_id)
      )");
      db_query("CREATE INDEX {versioncontrol_operations}_type_idx ON {versioncontrol_operations} (type)");
      db_query("CREATE INDEX {versioncontrol_operations}_repo_id_idx ON {versioncontrol_operations} (repo_id)");
      db_query("CREATE INDEX {versioncontrol_operations}_date_idx ON {versioncontrol_operations} (date)");
      db_query("CREATE INDEX {versioncontrol_operations}_uid_idx ON {versioncontrol_operations} (uid)");
      db_query("CREATE INDEX {versioncontrol_operations}_username_idx ON {versioncontrol_operations} (username)");
      db_query("CREATE INDEX {versioncontrol_operations}_revision_idx ON {versioncontrol_operations} (revision)");

      db_query("CREATE TABLE {versioncontrol_operation_labels} (
        vc_op_id int NOT NULL default 0,
        label_id int NOT NULL default 0,
        action smallint NOT NULL default 0,
        PRIMARY KEY (vc_op_id, label_id)
      )");

      db_query("CREATE TABLE {versioncontrol_labels} (
        label_id int NOT NULL default 0,
        repo_id int NOT NULL default 0,
        name varchar(255) NOT NULL default '',
        type smallint NOT NULL default 0,
        PRIMARY KEY (label_id),
        UNIQUE (repo_id, name, type)
      )");

      db_query("CREATE TABLE {versioncontrol_operation_items} (
        vc_op_id int NOT NULL default 0,
        item_revision_id int NOT NULL default 0,
        PRIMARY KEY (vc_op_id, item_revision_id)
      )");

      db_query("CREATE TABLE {versioncontrol_source_items} (
        item_revision_id int NOT NULL default 0,
        source_item_revision_id int NOT NULL default 0,
        action smallint NOT NULL default 0,
        PRIMARY KEY (item_revision_id, source_item_revision_id)
      )");

      db_query("CREATE TABLE {versioncontrol_item_revisions} (
        item_revision_id int NOT NULL default 0,
        repo_id int NOT NULL default 0,
        path varchar(255) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        type smallint NOT NULL default 0,
        PRIMARY KEY (item_revision_id),
        UNIQUE (repo_id, path)
      )");
      db_query("CREATE INDEX {versioncontrol_item_revisions}_revision_idx ON {versioncontrol_item_revisions} (revision)");

      db_query("CREATE TABLE {versioncontrol_repositories} (
        repo_id int NOT NULL default 0,
        name varchar(255) NOT NULL default '',
        vcs varchar(8) NOT NULL default '',
        root varchar(255) NOT NULL default '',
        authorization_method varchar(64) NOT NULL default '',
        url_backend varchar(64) NOT NULL default '',
        PRIMARY KEY (repo_id),
        UNIQUE (name)
      )");

      db_query("CREATE TABLE {versioncontrol_repository_urls} (
        repo_id int NOT NULL default 0,
        commit_view varchar(255) NOT NULL default '',
        file_log_view varchar(255) NOT NULL default '',
        file_view varchar(255) NOT NULL default '',
        directory_view varchar(255) NOT NULL default '',
        diff varchar(255) NOT NULL default '',
        tracker varchar(255) NOT NULL default '',
        PRIMARY KEY (repo_id)
      )");

      db_query("CREATE TABLE {versioncontrol_repository_metadata} (
        repo_id int NOT NULL default 0,
        weight smallint NOT NULL default 0,
        registration_message text,
        PRIMARY KEY (repo_id)
      )");

      db_query("CREATE TABLE {versioncontrol_accounts} (
        uid int NOT NULL default 0,
        repo_id int NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        PRIMARY KEY (uid, repo_id),
        UNIQUE (repo_id, username)
      )");
      break;
  }
}


/**
 * Implementation of hook_uninstall().
 */
function versioncontrol_uninstall() {
  $variables = array(
    'versioncontrol_email_address',
    'versioncontrol_allow_unauthorized_access',
    'versioncontrol_registration_message_unauthorized',
    'versioncontrol_registration_message_authorized',
    'versioncontrol_admin_account_pager',
  );
  foreach ($variables as $variable) {
    variable_del($variable);
  }

  db_query('DROP TABLE {versioncontrol_operations}');
  db_query('DROP TABLE {versioncontrol_labels}');
  db_query('DROP TABLE {versioncontrol_operation_labels}');
  db_query('DROP TABLE {versioncontrol_operation_items}');
  db_query('DROP TABLE {versioncontrol_source_items}');
  db_query('DROP TABLE {versioncontrol_item_revisions}');
  db_query('DROP TABLE {versioncontrol_repositories}');
  db_query('DROP TABLE {versioncontrol_repository_urls}');
  db_query('DROP TABLE {versioncontrol_repository_metadata}');
  db_query('DROP TABLE {versioncontrol_accounts}');
}


// Update functions.

function versioncontrol_update_1() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_repository_urls}
                           ADD COLUMN file_log_view varchar(255) NOT NULL default ''
                           AFTER commit_view");
      break;
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_repository_urls}
                           ADD COLUMN file_log_view varchar(255) NOT NULL default ''");
      break;
  }
  return $ret;
}

/**
 * Update 2: Merge {versioncontrol_commits}, {versioncontrol_tag_operations}
 *   and {versioncontrol_branch_operations} in one {versioncontrol_operations}
 *   table with just minor extensions remaining in the original tables.
 */
function versioncontrol_update_2() {
  $ret = array();

  // Step 1: Create the new master table, so we can move things over.
  //         Also create new vc_op_id columns in the old tables.
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("CREATE TABLE {versioncontrol_operations} (
        vc_op_id int unsigned NOT NULL default 0,
        type tinyint unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        date bigint NOT NULL default 0,
        uid int unsigned NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        directory varchar(255) NOT NULL default '',
        PRIMARY KEY (vc_op_id),
        KEY type (type),
        KEY repo_id (repo_id),
        KEY uid (uid),
        KEY date (date)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      // We'll keep commit ids, whereas tag op and branch op ids will be made up anew.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_commits} CHANGE COLUMN commit_id vc_op_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} ADD vc_op_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} ADD vc_op_id int unsigned NOT NULL default 0");
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {versioncontrol_operations} (
        vc_op_id int NOT NULL default 0,
        type smallint NOT NULL default 0,
        repo_id int NOT NULL default 0,
        date bigint NOT NULL default 0,
        uid int NOT NULL default 0,
        username varchar(64) NOT NULL default '',
        directory varchar(255) NOT NULL default '',
        PRIMARY KEY (vc_op_id)
      )");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_type_idx ON {versioncontrol_operations} (type)");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_repo_id_idx ON {versioncontrol_operations} (repo_id)");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_uid_idx ON {versioncontrol_operations} (uid)");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_date_idx ON {versioncontrol_operations} (date)");

      // We'll keep commit ids, whereas tag op and branch op ids will be made up anew.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_commits} RENAME commit_id TO vc_op_id");
      db_add_column($ret, 'versioncontrol_branch_operations', 'vc_op_id', 'int', array('not null' => TRUE, 'default' => 0));
      db_add_column($ret, 'versioncontrol_tag_operations', 'vc_op_id', 'int', array('not null' => TRUE, 'default' => 0));
      break;
  }

  // Step 2a) Transfer commits to the new table structure.
  $count = 0;
  $max_commit_id = 0;
  $result = db_query("SELECT * FROM {versioncontrol_commits}");

  while ($commit = db_fetch_object($result)) {
    ++$count;
    if ($commit->vc_op_id > $max_commit_id) {
      $max_commit_id = $commit->vc_op_id;
    }
    db_query("INSERT INTO {versioncontrol_operations}
              (vc_op_id, type, repo_id, date, uid, username, directory)
              VALUES (%d, 1, %d, %d, %d, '%s', '%s')",
              $commit->vc_op_id, $commit->repo_id, $commit->date,
              $commit->uid, $commit->username, $commit->directory);
  }
  // Increase the sequence counter for {versioncontrol_operations}
  // until it's as high as the maximum vc_op_id value.
  while ($max_commit_id >= db_next_id('{versioncontrol_operations}_vc_op_id')) {
    // continue;
  }

  if ($count > 0) {
    $ret[] = array(
      'success' => TRUE,
      'query' => "$count INSERT statements, moving most columns of {versioncontrol_commits} into {versioncontrol_operations}.",
    );
  }

  // Step 2b) Transfer branch operations to the new table structure.
  $count = 0;
  $result = db_query("SELECT * FROM {versioncontrol_branch_operations}");

  while ($branch_op = db_fetch_object($result)) {
    ++$count;
    $op_id = db_next_id('{versioncontrol_operations}_vc_op_id');
    $repo_id = db_result(db_query(
      "SELECT repo_id
       FROM {versioncontrol_branches} b
        INNER JOIN {versioncontrol_branch_operations} bo
         ON bo.branch_id = b.branch_id
       WHERE bo.branch_op_id = %d", $branch_op->branch_op_id
    ));

    db_query("INSERT INTO {versioncontrol_operations}
              (vc_op_id, type, repo_id, date, uid, username, directory)
              VALUES (%d, 2, %d, %d, %d, '%s', '%s')",
              $op_id, $repo_id, $branch_op->date,
              $branch_op->uid, $branch_op->username, $branch_op->directory);
    db_query("UPDATE {versioncontrol_branch_operations}
              SET vc_op_id = %d WHERE branch_op_id = %d",
              $op_id, $branch_op->branch_op_id);
  }

  // Step 2c) Transfer tag operations to the new table structure.
  $result = db_query("SELECT * FROM {versioncontrol_tag_operations}");

  while ($tag_op = db_fetch_object($result)) {
    ++$count;
    $op_id = db_next_id('{versioncontrol_operations}_vc_op_id');

    db_query("INSERT INTO {versioncontrol_operations}
              (vc_op_id, type, repo_id, date, uid, username, directory)
              VALUES (%d, 3, %d, %d, %d, '%s', '%s')",
              $op_id, $tag_op->repo_id, $tag_op->date,
              $tag_op->uid, $tag_op->username, $tag_op->directory);
    db_query("UPDATE {versioncontrol_tag_operations}
              SET vc_op_id = %d WHERE tag_op_id = %d",
              $op_id, $tag_op->tag_op_id);
  }

  if ($count > 0) {
    $ret[] = array(
      'success' => TRUE,
      'query' => "$count INSERT and $count UPDATE statements, moving most columns of {versioncontrol_branch_operations} and {versioncontrol_tag_operations} into {versioncontrol_operations}, and introducing vc_op_id as newly created primary key.",
    );
  }

  // Step 3) Also do the versioncontrol_cvs port, by calling the appropriate
  //         update function in versioncontrol_cvs.install.
  //         Other backends are not known or still unready for deployment,
  //         so they won't get a proper upgrade.
  $cvs_install_path = drupal_get_path('module', 'versioncontrol_cvs') .'/versioncontrol_cvs.install';
  if (file_exists($cvs_install_path)) {
    include_once($cvs_install_path);
    // The upgrade function some guarding logic so that it won't be applied
    // when called without that (arbitrary) parameter.
    if (function_exists('versioncontrol_cvs_update_2')) {
      $ret = array_merge($ret, versioncontrol_cvs_update_2('do the upgrade'));
    }
  }

  // Step 4a) Adapt indexes, and move the primary key to vc_op_id.
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      // Remove repo_id from the index, as it's being moved
      // to {versioncontrol_operations} and thus gone from this table.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} DROP KEY repo_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} ADD KEY (tag_name)");

      // Drop the previous primary keys and install vc_op_id as the new one.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} ADD PRIMARY KEY (vc_op_id)");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} ADD PRIMARY KEY (vc_op_id)");
      break;

    case 'pgsql':
      // Remove repo_id from the index, as it's being moved
      // to {versioncontrol_operations} and thus gone from this table.
      $ret[] = update_sql("DROP INDEX {versioncontrol_tag_operations}_repo_id_tag_name_idx");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_tag_operations}_tag_name_idx ON {versioncontrol_tag_operations} (tag_name)");

      // Drop the primary key constraint which would prohibit us from deleting
      // the primary key column, then add vc_op_id as the new primary key.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} DROP CONSTRAINT {versioncontrol_branch_operations}_pkey");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} ADD PRIMARY KEY (vc_op_id)");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} DROP CONSTRAINT {versioncontrol_tag_operations}_pkey");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_tag_operations} ADD PRIMARY KEY (vc_op_id)");
      break;
  }

  // Step 4b) Delete obsolete columns from the original tables.
  $ret[] = update_sql('ALTER TABLE {versioncontrol_commits} DROP COLUMN repo_id');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_commits} DROP COLUMN date');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_commits} DROP COLUMN uid');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_commits} DROP COLUMN username');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_commits} DROP COLUMN directory');

  $ret[] = update_sql('ALTER TABLE {versioncontrol_branch_operations} DROP COLUMN branch_op_id');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_branch_operations} DROP COLUMN date');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_branch_operations} DROP COLUMN uid');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_branch_operations} DROP COLUMN username');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_branch_operations} DROP COLUMN directory');

  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN tag_op_id');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN repo_id');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN date');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN uid');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN username');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_tag_operations} DROP COLUMN directory');

  return $ret;
}

/**
 * Update 3: Add an index to {versioncontrol_commits} (revision).
 *   (This was the last change for 5.x-1.x.)
 */
function versioncontrol_update_3() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_commits} ADD KEY (revision)");
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE INDEX {versioncontrol_commits}_revision_idx
                           ON {versioncontrol_commits} (revision)");
      break;
  }
  return $ret;
}

/**
 * Update 4: Include items and commit branches in the database scheme,
 *   and while doing so, have a major refactoring of all the operation tables.
 */
function versioncontrol_update_4() {
  $ret = array();

  // Directory is dropped for three reasons:
  // 1. It's hard to update if there's any reason to change it,
  // 2. With the exceptions for modified and deleted items, its workings are
  //    a bit difficult to understand and don't not generally applicable, plus
  // 3. With the new schema, it's not needed anymore as performance improvement.
  $ret[] = update_sql("ALTER TABLE {versioncontrol_operations} DROP COLUMN directory");

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      // Move 'revision' and 'message' to {versioncontrol_operations}, index
      // 'revision', and also index 'username' which had been forgotten before.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operations} ADD revision varchar(255) NOT NULL default ''");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operations} ADD message text");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operations} ADD KEY (username)");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operations} ADD KEY (revision)");

      // Move 'revision' and 'message' data from commits to operations,
      // and eliminate the commits table as there's no data left there.
      $ret[] = update_sql("UPDATE {versioncontrol_operations} op, {versioncontrol_commits} c
                           SET op.revision = c.revision, op.message = c.message
                           WHERE op.vc_op_id = c.vc_op_id");
      $ret[] = update_sql("DROP TABLE {versioncontrol_commits}");

      // Move 'message' from tag_operations to operations, but leave the table
      // as we still need to move more data later.
      $ret[] = update_sql("UPDATE {versioncontrol_operations} op, {versioncontrol_tag_operations} t
                           SET op.message = t.message
                           WHERE op.vc_op_id = t.vc_op_id");

      // Rename branches to labels, and add 'type' as additional unique key.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} DROP KEY repo_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} CHANGE COLUMN branch_id label_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} CHANGE COLUMN branch_name name varchar(255) NOT NULL default ''");
      $ret[] = update_sql("RENAME TABLE {versioncontrol_branches} TO {versioncontrol_labels}");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_labels} ADD type tinyint unsigned NOT NULL default 0");
      $ret[] = update_sql("UPDATE {versioncontrol_labels} SET type = 2"); // == VERSIONCONTROL_OPERATION_BRANCH
      $ret[] = update_sql("ALTER TABLE {versioncontrol_labels} ADD UNIQUE KEY (repo_id, name, type)");

      // Rename branch_operations to operation_labels.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} DROP KEY branch_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} CHANGE COLUMN branch_id label_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} DROP PRIMARY KEY");
      $ret[] = update_sql("RENAME TABLE {versioncontrol_branch_operations} TO {versioncontrol_operation_labels}");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operation_labels} ADD PRIMARY KEY (vc_op_id, label_id)");
      break;

    case 'pgsql':
      // Move 'revision' and 'message' to {versioncontrol_operations}, index
      // 'revision', and also index 'username' which had been forgotten before.
      db_add_column($ret, 'versioncontrol_operations', 'revision', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
      db_add_column($ret, 'versioncontrol_operations', 'message', 'text');
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_username_idx
                           ON {versioncontrol_operations} (username)");
      $ret[] = update_sql("CREATE INDEX {versioncontrol_operations}_revision_idx
                           ON {versioncontrol_operations} (revision)");

      // Move 'revision' and 'message' data from commits to operations,
      // and eliminate the commits table as there's no data left there.
      $ret[] = update_sql("UPDATE {versioncontrol_operations}
                           SET revision = c.revision, message = c.message
                           FROM {versioncontrol_commits} c
                           WHERE vc_op_id = c.vc_op_id");
      $ret[] = update_sql("DROP TABLE {versioncontrol_commits}");

      // Move 'message' from tag_operations to operations, but leave the table
      // as we still need to move more data later.
      $ret[] = update_sql("UPDATE {versioncontrol_operations}
                           SET message = t.message
                           FROM {versioncontrol_tag_operations} t
                           WHERE vc_op_id = t.vc_op_id");

      // Rename branches to labels, and add 'type' as additional unique key.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} DROP CONSTRAINT {versioncontrol_branches}_repo_id_key");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} DROP CONSTRAINT {versioncontrol_branches}_pkey");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} RENAME branch_id TO label_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} RENAME branch_name TO name");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branches} RENAME TO {versioncontrol_labels}");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_labels} ADD PRIMARY KEY (label_id)");
      db_add_column($ret, 'versioncontrol_labels', 'type', 'smallint', array('not null' => TRUE, 'default' => "0"));
      $ret[] = update_sql("UPDATE {versioncontrol_labels} SET type = 2"); // == VERSIONCONTROL_OPERATION_BRANCH
      $ret[] = update_sql("ALTER TABLE {versioncontrol_labels} ADD UNIQUE (repo_id, name, type)");

      // Rename branch_operations to operation_labels.
      $ret[] = update_sql("DROP INDEX {versioncontrol_branch_operations}_branch_id_idx");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} RENAME branch_id TO label_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} DROP CONSTRAINT {versioncontrol_branch_operations}_pkey");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_branch_operations} RENAME TO {versioncontrol_operation_labels}");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_operation_labels} ADD PRIMARY KEY (vc_op_id, label_id)");
      break;
  }

  // Increase the sequence counter for {versioncontrol_labels}
  // until it's as high as the maximum label_id value. This means that
  // previously existing branches will have lower label_ids than tags,
  // but whatever, it's not like that would matter in any way.
  $max_label_id = db_result(db_query("SELECT MAX(label_id) FROM {versioncontrol_labels}"));
  if ($max_label_id) {
    while ($max_label_id >= db_next_id('{versioncontrol_labels}_label_id')) {
      // continue;
    }
  }

  // Last modification task (for the API module, at least):
  // Move tag operations to the new label structure.
  $result = db_query("SELECT t.vc_op_id, t.tag_name, t.action, op.repo_id
                      FROM {versioncontrol_tag_operations} t
                       INNER JOIN {versioncontrol_operations} op
                        ON t.vc_op_id = op.vc_op_id"
  );
  while ($tag = db_fetch_array($result)) {
    $label_id = db_result(db_query(
      "SELECT label_id FROM {versioncontrol_labels} l
       WHERE l.repo_id = $tag[repo_id] AND l.name = '$tag[tag_name]'
         AND l.type = 3" // == VERSIONCONTROL_OPERATION_TAG
    ));
    if (!$label_id) {
      $label_id = db_next_id('{versioncontrol_labels}_label_id');
      $ret[] = update_sql(
        "INSERT INTO {versioncontrol_labels} (label_id, repo_id, name, type)
         VALUES ($label_id, $tag[repo_id], '$tag[tag_name]', 3)");
    }
    $ret[] = update_sql(
      "INSERT INTO {versioncontrol_operation_labels} (vc_op_id, label_id, action)
       VALUES ($tag[vc_op_id], $label_id, $tag[action])");
  }
  db_query('DROP TABLE {versioncontrol_tag_operations}');

  // Create the new tables. If this looks like a copy of the install function
  // to you... bingo, you got it.
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("CREATE TABLE {versioncontrol_operation_items} (
        vc_op_id int unsigned NOT NULL default 0,
        item_revision_id int unsigned NOT NULL default 0,
        PRIMARY KEY (vc_op_id, item_revision_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      $ret[] = update_sql("CREATE TABLE {versioncontrol_source_items} (
        item_revision_id int unsigned NOT NULL default 0,
        source_item_revision_id int unsigned NOT NULL default 0,
        action tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (item_revision_id, source_item_revision_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      $ret[] = update_sql("CREATE TABLE {versioncontrol_item_revisions} (
        item_revision_id int unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        path varchar(255) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        type tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (item_revision_id),
        UNIQUE KEY (repo_id, path),
        KEY revision (revision)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {versioncontrol_operation_items} (
        vc_op_id int NOT NULL default 0,
        item_revision_id int NOT NULL default 0,
        PRIMARY KEY (vc_op_id, item_revision_id)
      )");

      $ret[] = update_sql("CREATE TABLE {versioncontrol_source_items} (
        item_revision_id int NOT NULL default 0,
        source_item_revision_id int NOT NULL default 0,
        action smallint NOT NULL default 0,
        PRIMARY KEY (item_revision_id, source_item_revision_id)
      )");

      $ret[] = update_sql("CREATE TABLE {versioncontrol_item_revisions} (
        item_revision_id int NOT NULL default 0,
        repo_id int NOT NULL default 0,
        path varchar(255) NOT NULL default '',
        revision varchar(255) NOT NULL default '',
        type smallint NOT NULL default 0,
        PRIMARY KEY (item_revision_id),
        UNIQUE (repo_id, path)
      )");
      db_query("CREATE INDEX {versioncontrol_item_revisions}_revision_idx ON {versioncontrol_item_revisions} (revision)");
      break;
  }

  // Clean up after ourselves. A few ones were left from earlier updates, too.
  if (db_table_exists('sequences')) {
    $ret[] = update_sql("DELETE FROM {sequences} WHERE name = '{versioncontrol_branches}_branch_id'");
    $ret[] = update_sql("DELETE FROM {sequences} WHERE name = '{versioncontrol_commits}_commit_id'");
    $ret[] = update_sql("DELETE FROM {sequences} WHERE name = '{versioncontrol_tag_operations}_tag_op_id'");
    $ret[] = update_sql("DELETE FROM {sequences} WHERE name = '{versioncontrol_branch_operations}_branch_op_id'");
  }

  return $ret;
}
